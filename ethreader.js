// Generated by Haxe 3.4.0
if (process.version < "v4.0.0") console.warn("Module " + (typeof(module) == "undefined" ? "" : module.filename) + " requires node.js version 4.0.0 or higher");
(function ($hx_exports) { "use strict";
$hx_exports["ethreader"] = $hx_exports["ethreader"] || {};
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.foreach = function(it,f) {
	var x = $iterator(it)();
	while(x.hasNext()) {
		var x1 = x.next();
		if(!f(x1)) {
			return false;
		}
	}
	return true;
};
var ethreader_EthReader = function() { };
var ethreader_EtherscanReader = $hx_exports["ethreader"]["EtherscanReader"] = function(apiKey) {
	this._apiKey = apiKey;
};
ethreader_EtherscanReader.__interfaces__ = [ethreader_EthReader];
ethreader_EtherscanReader.prototype = {
	newTransactionReader: function(address) {
		return new ethreader_TransactionsReader(address,this);
	}
	,getAbi: function(address,onData) {
		var options = { host : "api.etherscan.io", path : "/api?module=contract&action=getabi&address=" + address + "&apikey=" + this._apiKey};
		var callback = null;
		callback = function(response) {
			var str = "";
			response.on("data",function(chunk) {
				str += chunk;
			});
			response.on("error",function(err) {
				onData(err,null);
			});
			response.on("end",function(chunk1) {
				var abi = null;
				var err1 = null;
				try {
					var result = JSON.parse(str);
					abi = JSON.parse(result.result);
				} catch( e ) {
					abi = null;
					err1 = "no abi for " + address;
				}
				if(err1 != null) {
					onData(err1,null);
				} else {
					onData(null,abi);
				}
			});
		};
		console.log("getting abi from etherscan...");
		js_node_Http.request(options,callback).end();
	}
	,getTransactions: function(address,startBlock,endBlock,onData) {
		var options = { host : "api.etherscan.io", path : "/api?module=account&action=txlist&address=" + address + "&startblock=" + startBlock + "&endblock=" + endBlock + "&sort=asc&apikey=" + this._apiKey};
		var callback = null;
		callback = function(response) {
			var str = "";
			response.on("data",function(chunk) {
				str += chunk;
			});
			response.on("error",function(err) {
				onData(err,null);
			});
			response.on("end",function(chunk1) {
				var transactions = null;
				var err1 = null;
				try {
					var result = JSON.parse(str);
					transactions = result.result;
				} catch( e ) {
					transactions = null;
					err1 = e;
				}
				if(err1 != null) {
					onData(err1,null);
				} else {
					onData(null,transactions);
				}
			});
		};
		console.log("getting transactions from etherscan...");
		var request = js_node_Http.request(options,callback);
		request.end();
	}
};
var parity_api_Transport = require("@parity/parity.js").Api.Transport;
var ethreader_FakeTransport = function() {
};
ethreader_FakeTransport.__super__ = parity_api_Transport;
ethreader_FakeTransport.prototype = $extend(parity_api_Transport.prototype,{
	execute: function() {
	}
	,addMiddleware: function(d) {
	}
});
var parity_Api = require("@parity/parity.js").Api;
var ethreader_TransactionsReader = function(address,ethReader) {
	this._abiMap = null;
	this._address = address;
	this._ethReader = ethReader;
};
ethreader_TransactionsReader.prototype = {
	collect: function(callback,startBlock,endBlock) {
		if(endBlock == null) {
			endBlock = 2147483647;
		}
		if(startBlock == null) {
			startBlock = 0;
		}
		var _gthis = this;
		if(this._abiMap == null) {
			console.log("getting abi from ethreader...");
			this._ethReader.getAbi(this._address,function(error,abi) {
				if(error != null) {
					callback(error,null);
				} else {
					console.log("converting abi to abimap");
					var methodAbiMap = new haxe_ds_StringMap();
					var _g = 0;
					while(_g < abi.length) {
						var methodAbi = abi[_g];
						++_g;
						var k = methodAbi.name;
						if(__map_reserved[k] != null) {
							methodAbiMap.setReserved(k,methodAbi);
						} else {
							methodAbiMap.h[k] = methodAbi;
						}
					}
					var contract = ethreader_TransactionsReader._api.newContract(abi);
					_gthis._abiMap = new haxe_ds_StringMap();
					Lambda.foreach(contract.functions,function(fn) {
						if(fn != null && fn.signature != null) {
							var this1 = _gthis._abiMap;
							var k1 = "0x" + fn.signature;
							var key = fn.name;
							var v = __map_reserved[key] != null ? methodAbiMap.getReserved(key) : methodAbiMap.h[key];
							var _this = this1;
							if(__map_reserved[k1] != null) {
								_this.setReserved(k1,v);
							} else {
								_this.h[k1] = v;
							}
						}
						return true;
					});
					_gthis._collect(startBlock,endBlock,callback);
				}
			});
		} else {
			this._collect(startBlock,endBlock,callback);
		}
	}
	,_collect: function(startBlock,endBlock,callback) {
		var _gthis = this;
		console.log("getting transactions from ethreader...");
		this._ethReader.getTransactions(this._address,startBlock,endBlock,function(error,transactions) {
			if(error != null) {
				callback(error,null);
			} else {
				console.log("decoding...");
				var _g = 0;
				while(_g < transactions.length) {
					var transaction = transactions[_g];
					++_g;
					if(transaction.input == "0x") {
						continue;
					}
					var callData = ethreader_TransactionsReader._api.util.decodeCallData(transaction.input);
					var key = callData.signature;
					var _this = _gthis._abiMap;
					var methodAbi = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
					if(methodAbi != null) {
						var inputArray = ethreader_TransactionsReader._api.util.decodeMethodInput(methodAbi,callData.paramdata);
						var decoded_input = { };
						var _g2 = 0;
						var _g1 = inputArray.length;
						while(_g2 < _g1) {
							var j = _g2++;
							decoded_input[methodAbi.inputs[j].name] = inputArray[j];
						}
						transaction.decoded_call = { "name" : methodAbi.name, "input" : decoded_input};
					} else {
						console.log("no method with signature " + callData.signature);
					}
				}
				callback(null,transactions);
			}
		});
	}
	,getFromFile: function(filename,callback) {
		js_node_Fs.readFile(filename,function(err,result) {
			if(err != null) {
				callback(err,null);
			} else if(result.toString() == "") {
				callback("nothing",null);
			} else {
				var tmp = result.toString();
				callback(err,tmp);
			}
		});
	}
};
var haxe_IMap = function() { };
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
};
var haxe_io_Bytes = function() { };
var js_node_Fs = require("fs");
var js_node_Http = require("http");
var js_node_buffer_Buffer = require("buffer").Buffer;
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
var transport = new ethreader_FakeTransport();
ethreader_TransactionsReader._api = new parity_Api(transport);
var __map_reserved = {}
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
